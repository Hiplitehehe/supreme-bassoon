"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isStringArrayStringOrFunc = exports.Util = void 0;
const events_1 = __importDefault(require("events"));
/**
 * Akairo Utilities.
 */
class Util {
    /**
     * Deep assign properties to an object.
     * @param target The object to assign values to.
     * @param os The objects to assign from.
     */
    static deepAssign(target, ...os) {
        for (const o of os) {
            for (const [key, value] of Object.entries(o)) {
                const valueIsObject = value && typeof value === "object";
                const targetKeyIsObject = Object.prototype.hasOwnProperty.call(target, key) &&
                    target[key] &&
                    typeof target[key] === "object";
                if (valueIsObject && targetKeyIsObject) {
                    Util.deepAssign(target[key], value);
                }
                else {
                    target[key] = value;
                }
            }
        }
        return target;
    }
    /**
     * Converts the supplied value into an array if it is not already one.
     * @param x - Value to convert.
     */
    static intoArray(x) {
        if (Array.isArray(x)) {
            return x;
        }
        return [x];
    }
    /**
     * Converts something to become callable.
     * @param thing - What to turn into a callable.
     * @returns - The callable.
     */
    static intoCallable(thing) {
        if (typeof thing === "function") {
            return thing;
        }
        return () => thing;
    }
    /**
     * Checks if the supplied value is an event emitter.
     * @param value - Value to check.
     * @returns - Whether the value is an event emitter.
     */
    static isEventEmitter(value) {
        return value instanceof events_1.default;
    }
    /**
     * Checks if the supplied value is a promise.
     * @param value - Value to check.
     * @returns - Whether the value is a promise.
     */
    static isPromise(value) {
        return value instanceof Promise;
    }
    /**
     * Compares two prefixes.
     * @param aKey - First prefix.
     * @param bKey - Second prefix.
     * @returns - Comparison result.
     */
    static prefixCompare(aKey, bKey) {
        if (aKey === "" && bKey === "")
            return 0;
        if (aKey === "")
            return 1;
        if (bKey === "")
            return -1;
        if (typeof aKey === "function" && typeof bKey === "function")
            return 0;
        if (typeof aKey === "function")
            return 1;
        if (typeof bKey === "function")
            return -1;
        return aKey.length === bKey.length ? aKey.localeCompare(bKey) : bKey.length - aKey.length;
    }
    // eslint-disable-next-line complexity
    static deepEquals(a, b, options) {
        const { ignoreUndefined = true, ignoreArrayOrder = true } = options ?? {};
        if (a === b)
            return true;
        if (typeof a !== "object" || typeof b !== "object")
            throw new TypeError("Not objects");
        if ((Array.isArray(a) && !Array.isArray(b)) || (!Array.isArray(a) && Array.isArray(b)))
            return false;
        const newA = ignoreArrayOrder && Array.isArray(a) && a.length && typeof a[0] !== "object" ? [...a].sort() : a;
        const newB = ignoreArrayOrder && Array.isArray(b) && b.length && typeof b[0] !== "object" ? [...b].sort() : b;
        for (const key in newA) {
            if (ignoreUndefined && newA[key] === undefined && newB[key] === undefined)
                continue;
            if (!(key in newB))
                return false;
            if (typeof newA[key] === "object" && typeof newB[key] === "object") {
                if (!this.deepEquals(newA[key], newB[key], { ignoreUndefined, ignoreArrayOrder }))
                    return false;
            }
            else if (newA[key] !== newB[key])
                return false;
        }
        for (const key in newB) {
            if (ignoreUndefined && newA[key] === undefined && newB[key] === undefined)
                continue;
            if (!(key in newA))
                return false;
            if (typeof newB[key] === "object" && typeof newA[key] === "object") {
                if (!this.deepEquals(newA[key], newB[key], { ignoreUndefined, ignoreArrayOrder }))
                    return false;
            }
            else if (newA[key] !== newB[key])
                return false;
        }
        return true;
    }
    /**
     * Converts a string in snake_case to camelCase.
     * @param str The string to convert.
     */
    static snakeToCamelCase(str) {
        return str
            .toLowerCase()
            .split("_")
            .map((word, index) => {
            if (index !== 0)
                return word.charAt(0).toUpperCase() + word.slice(1);
            return word;
        })
            .join("");
    }
    /**
     * Converts a string in PascalCase to camelCase.
     * @param str The string to convert.
     */
    static pascalToCamelCase(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    }
    /**
     * Checks if `array` is an array and its elements are typeof of `type`
     * @param array The array to check.
     * @param type The type to check the elements' type against.
     * @returns Whether the array is an array and its elements are typeof of `type`.
     */
    static isArrayOf(array, type) {
        if (!Array.isArray(array))
            return false;
        return array.every(item => typeof item === type);
    }
}
exports.Util = Util;
/**
 * Checks if a value is a string, an array of strings, or a function
 * @internal
 */
function isStringArrayStringOrFunc(value) {
    return typeof value === "string" || typeof value === "function" || Util.isArrayOf(value, "string");
}
exports.isStringArrayStringOrFunc = isStringArrayStringOrFunc;
//# sourceMappingURL=Util.js.map